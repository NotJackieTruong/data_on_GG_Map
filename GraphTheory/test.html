<!DOCTYPE html>
<html>

<head>
    <script src="jquery-3.4.1.js"></script>
    <title>
        Test
    </title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>
        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
        }

        .header {
            background-color: #5c5c5c;
            padding: 20px;
            text-align: center;
        }

        .bottom {
            background-color: #5c5656;
            padding: 20px;
            text-align: center;
        }

        div.result {
            margin-top: 10px;
            margin-bottom: 10px;
        }

        div.btn {
            margin-top: 5px;
        }

        .text-box {
            width: 300px;
            height: 30px;
        }

        #input {
            height: 200px;
            width: 500px;
            font-family: "Courier New", Courier, monospace;
        }

        .column {
            float: left;
            width: 50%;
            padding: 15px;
            height: 600px;
            /* text-align: center; */
            background-color: whitesmoke;
            border: 1px solid gray;

        }

        .column2 {
            float: left;
            width: 50%;
            padding: 15px;
            height: 600px;
            /* text-align: center; */
            background-color: whitesmoke;
            border: 1px solid gray;

        }

        .row:after {
            content: "";
            display: table;
            clear: both;
        }

        @media screen and (max-width:600px) {
            .column {
                width: 100%;
            }
        }
    </style>
</head>

<body>
    <textarea id="input" class="u-full-width" placeholder="Input your matrix here"></textarea>
    <input id="go" class="button-primary" type="submit" value="Create Graph">

    <div class="row">
        <div class="column">
            <div class="input-node">
                <p>Input</p>
                <input class='text-box' id='node_name' type="text" placeholder="Enter node">
                <div class="btn">
                    <button type="submit" onclick="getNodeText()">Enter</button>
                </div>
            </div>
            <div class="results">
                <p>Results: </p>
                <div class="result">
                    <p> Degree of the node</p>
                    <input class='text-box' id='degree' type="text">
                </div>
                <div class="result">
                    <p> Adjacencies of the node</p>
                    <input class='text-box' id='Adj' type="text">
                </div>
            </div>
            <div class="input-path">
                <p>Input Starting Node and Target Node</p>
                <input class='text-box' id='start' type="text" placeholder="Start node">
                <input class='text-box' id='end' type="text" placeholder="Target node">
                <div class="btn">
                    <button type="submit" onclick="getPathNode()">Enter</button>
                </div>
            </div>
            <div class="results">
                <p>Results: </p>
                <div class="result">
                    <p> Path between 2 nodes</p>
                    <input class='text-box' id='path' type="text">
                </div>
            </div>
        </div>

        <div class="column2">
            <div class="input-path">
                <div class="btn">
                    <button type="submit" onclick="miniSpanTree()">Minimum Spanning tree</button>
                </div>
            </div>
            <div class="results">
                <div class="result">
                    <p>Results: </p>
                    <input style="width: 240px; height: 240px;" class='text-box' id='spanning-tree' type="text">
                </div>
            </div>
        </div>
    </div>

    <script>
        /* * 1 2 3 4 
1 0 1 1 0
2 1 0 1 0
3 1 1 0 1
4 0 0 1 0*/
        var matrix = [];
        // Queue class 
        class Queue {
            // Array is used to implement a Queue 
            constructor() {
                this.items = [];
            }
            // enqueue function 
            enqueue(element) {
                // adding element to the queue 
                this.items.push(element);
            }
            // dequeue function 
            dequeue() {
                // removing element from the queue 
                // returns underflow when called 
                // on empty queue 
                if (this.isEmpty())
                    return "Underflow";
                return this.items.shift();
            }
            // front function 
            front() {
                // returns the Front element of 
                // the queue without removing it. 
                if (this.isEmpty())
                    return "No elements in Queue";
                return this.items[0];
            }
            // isEmpty function 
            isEmpty() {
                // return true if the queue is empty. 
                return this.items.length == 0;
            }
            // printQueue function 
            printQueue() {
                var str = "";
                for (var i = 0; i < this.items.length; i++)
                    str += this.items[i] + " ";
                return str;
            }

        }
        // create a graph class 
        class Graph {
            // defining vertex array and 
            // adjacent list 
            constructor(noOfVertices) {
                this.noOfVertices = noOfVertices;
                this.AdjList = new Map();
            }
            // add vertex to the graph 
            addVertex(v) {
                // initialize the adjacent list with a 
                // null array 
                this.AdjList.set(v, []);
            }
            addEdgeWeighted(v, w, weight) {
                // get the list for vertex v and put the 
                // vertex w denoting edge between v and w 
                this.AdjList.get(v).push({ Node: w, weighted: weight });

                // Since graph is undirected, 
                // add an edge from w to v also 
                this.AdjList.get(w).push({ Node: v, weighted: weight });
            }

            checkifExist(user_input) {
                var get_keys = this.AdjList.keys();

                // iterate over the vertices 
                for (var i of get_keys) {
                    // great the corresponding adjacency list 
                    // for the vertex 
                    var get_values = this.AdjList.get(i);
                    var message;
                    // iterate over the adjacency list 
                    // concatenate the values into a string 
                    for (var j of get_values)
                        if (user_input == j.Node) {
                            console.log(user_input)
                            message = 'found'
                            console.log(message)
                        }
                }
                if (message != 'found') {
                    message = 'not found'
                    alert(message)
                }
            }

            AdjOfVertice(node) {
                var get_keys = this.AdjList.keys();
                for (var i of get_keys) {
                    // great the corresponding adjacency list 
                    // for the vertex 
                    if (i == node) {
                        var get_values = this.AdjList.get(i);
                        var conc = [];
                        // iterate over the adjacency list 
                        // concatenate the values into a string 
                        for (var j of get_values) {
                            conc.push(j.Node)
                        }
                        console.log("Incoming/OutComing Adjacency of " + i + " -> " + conc);
                    }

                    // print the vertex and its adjacency list 

                }
                return conc
            }
            degreeOfVertice(node) {
                var get_keys = this.AdjList.keys();
                for (var i of get_keys) {
                    // great the corresponding adjacency list 
                    // for the vertex 
                    if (i == node) {
                        var get_values = this.AdjList.get(i);
                        var conc = 0;
                        // iterate over the adjacency list 
                        // concatenate the values into a string 
                        for (var j of get_values) {
                            conc += 1
                        }
                        console.log("Degree of " + i + " is: " + conc);
                    }

                    // print the vertex and its adjacency list 

                }
                return conc
            }
            // function to search path between node applying BFS
            searchPath(s, f) {
                var path = []
                var startingNode, finishingNode
                if (this.degreeOfVertice(s) < this.degreeOfVertice(f)) {
                    startingNode = s
                    finishingNode = f
                }
                else {
                    startingNode = f
                    finishingNode = s
                }
                console.log("The peferred path is from " + startingNode + " to " + finishingNode)
                // create a visited array 
                var visited = [];
                for (var i = 0; i < this.noOfVertices; i++)
                    visited[i] = false;

                // Create an object for queue 
                var q = new Queue();

                // add the starting node to the queue 
                visited[startingNode] = true;
                q.enqueue(startingNode);
                var getQueueElement
                // loop until queue is element 
                while (getQueueElement != finishingNode) {
                    // get the element from the queue 
                    getQueueElement = q.dequeue();
                    path.push(getQueueElement)

                    // passing the current vertex to callback funtion
                    // get the adjacent list for current vertex 
                    var get_List = this.AdjList.get(getQueueElement);

                    // loop through the list and add the element to the 
                    // queue if it is not processed yet 
                    for (var i in get_List) {
                        var neigh = get_List[i].Node;
                        if (!visited[neigh]) {
                            if (neigh != finishingNode) {
                                visited[neigh] = true;
                                q.enqueue(neigh);
                            }
                            else {
                                getQueueElement = finishingNode
                                console.log(finishingNode)
                                path.push(finishingNode)
                            }
                        }
                    }

                }
                return path
            }
            printTest() {
                console.log(this.AdjList)
            }
            listEdge() {
                var edge = []
                var get_keys = this.AdjList.keys();
                for (var i of get_keys) {
                    // great the corresponding adjacency list 
                    // for the vertex 
                    var get_values = this.AdjList.get(i);
                    // iterate over the adjacency list 
                    // console.log(edge,get_values)
                    for (var j of get_values) {
                        edge.push({ node1: i, node2: j.Node, weighted: j.weighted })
                        // console.log(i,j.Node,j.weighted)
                    }
                }
                for (var i = 0; i < edge.length; i++) {
                    for (var j = 0; j < edge.length; j++) {
                        if (edge[i].node1 == edge[j].node2 && edge[i].node2 == edge[j].node1) {
                            edge.splice(j, 1)
                        }
                    }
                }
                console.log(edge)
                return edge
            }
            listEdge2() {
                var edge = []
                var get_keys = this.AdjList.keys();
                for (var i of get_keys) {
                    // great the corresponding adjacency list 
                    // for the vertex 
                    var get_values = this.AdjList.get(i);
                    // iterate over the adjacency list 
                    // console.log(edge,get_values)
                    for (var j of get_values) {
                        edge.push({ node1: i, node2: j.Node, weighted: j.weighted })
                        // console.log(i,j.Node,j.weighted)
                    }
                }
                // for (var i = 0; i < edge.length; i++) {
                //     for (var j = 0; j < edge.length; j++) {
                //         if (edge[i].node1 == edge[j].node2 && edge[i].node2 == edge[j].node1) {
                //             edge.splice(j, 1)
                //         }
                //     }
                // }
                // console.log(edge)
                return edge
            }
            MNStree() {

                // sort all edges by weight
                var sortedEdge = this.listEdge()
                sortedEdge = sortedEdge.sort(function (a, b) { return a.weighted - b.weighted })
                var visited = [];
                var checkArray = []
                var weight = 0
                for (var i = 0; i < this.noOfVertices; i++)
                    visited[i] = false;
                for (var i = 0; i < sortedEdge.length; i++) {
                    if (!visited[sortedEdge[i].node1] || !visited[sortedEdge[i].node2]) {
                        checkArray.push(sortedEdge[i])
                        visited[sortedEdge[i].node1] = true
                        visited[sortedEdge[i].node2] = true
                        weight += sortedEdge[i].weighted
                    }
                }
                var textLine = ''
                for (var j = 0; j < checkArray.length; j++) {
                    textLine = textLine + "From " + checkArray[j].node1 + ' to ' + checkArray[j].node2 + "<br>"
                }
                console.log(textLine)
                console.log(checkArray, weight)
                return String(textLine)

            }
            EulerCircuit() {
                var edgeList = this.listEdge2()
                console.log(edgeList)
                var startV = null
                var path = []
                for (var i = 0; i < edgeList.length; i++) {
                    if (startV == null) {
                        startV = edgeList[i].node2
                        path.push(edgeList[i].node1)
                        path.push(edgeList[i].node2)
                        edgeList.splice(i, 1)
                    }
                    for (var j = 0; j < edgeList.length; j++) {
                        if (edgeList[j].node1 == startV) {
                            startV = edgeList[j].node2
                            path.push(edgeList[j].node1)
                            path.push(edgeList[j].node2)
                            edgeList.splice(j, 1)

                        }
                    }
                }
                console.log(path)

            }
            // function to performs BFS 
            bfs(startingNode) {

                // create a visited array 
                var visited = [];
                for (var i = 0; i < this.noOfVertices; i++)
                    visited[i] = false;

                // Create an object for queue 
                var q = new Queue();

                // add the starting node to the queue 
                visited[startingNode] = true;
                q.enqueue(startingNode);
                var count = 0
                // loop until queue is element 
                while (!q.isEmpty()) {
                    // get the element from the queue 
                    var getQueueElement = q.dequeue();

                    // passing the current vertex to callback funtion 
                    console.log(getQueueElement);
                    count ++
                    // get the adjacent list for current vertex 
                    var get_List = this.AdjList.get(getQueueElement);
                    console.log(get_List)
                    // loop through the list and add the element to the 
                    // queue if it is not processed yet 
                    for (var i in get_List) {
                        var neigh = get_List[i].Node;

                        if (!visited[neigh]) {
                            visited[neigh] = true;
                            q.enqueue(neigh);
                        }
                    }
                }
                if(count == (matrix.length -1))
                return true
                else
                return false
            }
        
            isEulerCircus(){
                var get_keys = this.AdjList.keys();

                // iterate over the vertices 
                for (var i of get_keys) {
                    // great the corresponding adjacency list 
                    // for the vertex 
                    var get_values = this.AdjList.get(i);
                    var message;
                    // iterate over the adjacency list 
                    // concatenate the values into a string 
                    var count = 0
                    for (var j of get_values){
                        if(this.degreeOfVertice(j.Node) % 2 == 0){
                            count ++
                        }
                    }
                    if(count == (matrix.length -1))
                return true
                else
                return false
                }

            }
        }
        // var matrix = [["", "CH", "B", "NY", "W", "P", "CI", "A", "ME", "NO", "MI"], ["CH", 0, 1, 1, 0, 1, 1, 0, 1, 0, 0], ["B", 1, 0, 1, 0, 0, 0, 0, 0, 0, 0], ["NY", 1, 1, 0, 1, 1, 0, 0, 0, 0, 0], ["W", 0, 0, 1, 0, 1, 0, 1, 0, 0, 1], ["P", 1, 0, 1, 1, 0, 1, 1, 0, 0, 0], ["CI", 1, 0, 0, 1, 1, 0, 1, 0, 0, 0], ["A", 0, 0, 0, 1, 1, 1, 0, 1, 1, 1], ["ME", 1, 0, 0, 0, 0, 0, 1, 0, 1, 0], ["NO", 0, 0, 0, 0, 0, 0, 1, 1, 0, 0], ["MI", 0, 0, 0, 1, 0, 0, 1, 0, 0, 0]]
        // console.log(matrix)
        var g
        function initGraph(matrix) {
            g = new Graph(matrix.length - 1)
            for (var v = 0; v < matrix.length - 1; v++) {
                g.addVertex(matrix[0][v + 1]);
            }
            for (var v = 0; v < matrix.length - 1; v++) {
                for (var j = v; j < matrix.length - 1; j++) {
                    if (matrix[j + 1][v + 1] != 0) {
                        // console.log(matrix[0][v + 1], matrix[j + 1][0])
                        g.addEdgeWeighted(matrix[0][v + 1], matrix[j + 1][0], parseInt(matrix[j + 1][v + 1]))
                    }
                }
            }
            g.printTest()
            g.EulerCircuit()
            g.bfs(matrix[0][1])
            if(!(g.isEulerCircus()) && !(g.bfs())){
                console.log("Euler Circus")
            }
            // g.EulerCircuit()
        }
        $('#go').click(function () {
            matrix = []
            var lines = $('#input').val().split(/\n/);
            var outputText;
            for (var i = 0; i < lines.length; i++) {
                // only push this line if it contains a non whitespace character.
                if (/\S/.test(lines[i])) {
                    outputText = lines[i].split(' ')
                    matrix.push(outputText);
                }
            }
            initGraph(matrix)
            if (matrix.length != 0)
                alert('Graph created')
            else alert('Insert Matrix')
        })
        // g.printTest()
        function getPathNode() {
            var start_input = document.getElementById('start').value
            var end_input = document.getElementById('end').value
            g.checkifExist(start_input)
            g.checkifExist(end_input)
            document.getElementById('path').value = g.searchPath(start_input, end_input)

        }
        function getNodeText() {
            var text_input = document.getElementById('node_name').value
            g.checkifExist(text_input)
            document.getElementById('degree').value = g.degreeOfVertice(text_input)

            document.getElementById('Adj').value = g.AdjOfVertice(text_input)
        }
        function miniSpanTree() {
            // document.getElementById('spanning-tree').innerHTML = g.MNStree()
            document.getElementById("spanning-tree").insertAdjacentHTML("afterend",
                g.MNStree());
        }

    </script>
</body>

</html>